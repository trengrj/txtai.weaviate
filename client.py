"""
Weaviate client module
"""

import weaviate
import logging

from txtai.pipeline import Pipeline

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.DEBUG)

class Weaviate(Pipeline):
    """
    Weaviate pipeline client. Supports indexing and searching content with Weaviate.
    """

    def __init__(self, url="http://localhost:8080", class_name="Post"):
        """
        Create a new client.

        Args:
            url: Weaviate service url
        """

        self.client = weaviate.Client(url)
        self.class_name = class_name

        # Delete autogenerated schema
        self.client.schema.delete_all()

    def __call__(self, inputs, action="index"):
        """
        Executes an action with Weaviate.

        Args:
            inputs: data inputs
            action: action to perform - index or search

        Returns:
            results
        """

        if action == "index":
            #return [self.index(data, vector) for data, vector in inputs]
            return self.index_batch(inputs)

        # Default to search action
        return [self.search(vector) for vector in inputs]

    def index(self, data, vector):
        """
        Indexes data-vector pair in Weaviate.

        Args:
            data: record metadata
            vector: record embeddings

        Returns:
            uuid from Weaviate
        """

        return self.client.data_object.create(
            {"content": data},
            self.class_name,
            vector = vector,
        )

    def index_batch(self, inputs):
        """
        Indexes a batch into Weaviate

        Args:
            inputs: data inputs

        Returns:
            list of uuids from Weaviate

        """
        logging.info(f"Indexing batch of length {len(inputs)}")
        self.client.batch.configure(batch_size=None)
        with self.client.batch as batch:
            for data, vector in inputs:
                batch.add_data_object(
                    vector=vector,
                    data_object={"content": data},
                    class_name=self.class_name
                )
            results = batch.create_objects()
        if results is not None:
            for result in results:
                if "result" in result and "errors" in result["result"]:
                    if "error" in result["result"]["errors"]:
                        logging.error(result["result"]["errors"]["error"])
        return [doc["id"] for doc in results if "id" in doc]

    def search(self, vector):
        """
        Runs a search using input vector.

        Args:
            vector: input vector

        Returns:
            search results
        """

        nearvector = {"vector": vector}
        return self.client.query.get(self.class_name, ["content", "_additional {certainty}"]).with_near_vector(nearvector).with_limit(1).do()
